<!DOCTYPE html>
<html>
<head>
  <title>Visualisation</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <!--<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>-->
  <script src="jquery-2.1.1.min.js"></script>
</head>
<body>
<h1>Visualisation</h1>
<script>
const colors = 'navy,black'.split(',')

$.get('cavern.json', (data) => {
  console.log('Visualistion Data', data)
  let cavern = data
  let { cells, creatures } = data
  const floorTiles = cells.filter(cell => !cell.wall)
  const floorTileMap = floorTiles.reduce((acc, tile) => {
    acc[`${tile.x},${tile.y}`] = tile
    return acc
  }, {})

  let creatureMap = {}
  function updateCreatureMap(creatures) {
    creatureMap = creatures.reduce((acc, creature) => {
      acc[`${creature.x},${creature.y}`] = creature
      return acc
    }, {})
  }
  updateCreatureMap(creatures)

  let boundary = {
    top: 0,
    left: 0,
    columns: cells.reduce((acc, cell) => {
      return Math.max(acc, cell.x)
    }, 0) + 1,
    rows: cells.reduce((acc, cell) => {
      return Math.max(acc, cell.y)
    }, 0) + 1,
  }

  $buttonForward = $('<button>+1 step</button>')
  $buttonForward.on('click', () => {
  })

  $chart = $(`<div class="chart"></div>`)
  $('body').append($buttonForward)
  $('body').append($chart)

  const cellTypeMap = {
    '.': 'f',
    '#': 'w'
  }

  $cells = []
  cells.forEach(cell => {
    let cellType = cell.wall ? '#' : '.'
    let $cell = $(`<b class="${cellTypeMap[cellType]}">${cellType}</b>`)
    $cell.data = cell
    cell.$el = $cell
    $cells.push($cell)
  })

  const creatureTypeMap = {
    'E': 'e',
    'G': 'g'
  }

  $creatures = []
  creatures.forEach(creature => {
    let creatureType = creatureTypeMap[creature.side]
    let $creature = $(`<i class="${creatureType}">${creature.side}</b>`)
    $creature.data = creature
    creature.$el = $creature
    $creatures.push($creature)
  })

  $chart.append($cells, $creatures)
  $chart.width((boundary.columns * 10) + 'px')
  console.log('Boundary', boundary)

  function renderCreaturePositions($creatures) {
    $creatures.forEach($creature => {
      $creature.css('left', ($creature.data.x * 10) + 'px')
      $creature.css('top', ($creature.data.y * 10) + 'px')
      $creature.on('mouseover', () => displayCreatureActions($creature))
      //$creature.on('mouseout', () => displayActions([]))
    })
  }

  $actionTiles = []
  function getActionTile(n) {
    if ($actionTiles.length <= n) {
      $actionTiles.push($(`<a></a>`))
    }
    return $actionTiles[n]
  }

  function tileEmpty(x, y) {
    const key = `${x},${y}`
    return floorTileMap[key] && !creatureMap[key]
  }

  function findEmptyTiles() {
    return floorTiles.filter(tile => tileEmpty(tile.x, tile.y))
  }

  function displayCreatureActions($creature) {
    let creature = $creature.data
    let actions = calculateCreatureActions(creature, cells, creatures)
    displayActions(actions)
  }

  const adjacentDirections = [
    {x: 0, y: -1},
    {x: 0, y: 1},
    {x: -1, y: 0},
    {x: 1, y: 0}
  ]

  function calculateCreatureActions(creature, cells, creatures) {
    let actions = adjacentDirections.map(direction => {
      return {
        type: 'move',
        symbol: 'm',
        x: creature.x + direction.x,
        y: creature.y + direction.y
      }
    }).filter(action => tileEmpty(action.x, action.y))

    const enemies = creatures.filter(other => other.side !== creature.side)
    const targets = []
    enemies.forEach(enemy => {
      const spaces = adjacentDirections.map(direction => {
        return {
          type: 'target',
          symbol: 't',
          x: enemy.x + direction.x,
          y: enemy.y + direction.y
        }
      }).filter(action => tileEmpty(action.x, action.y))
      spaces.forEach(space => targets.push(space))
    })
    actions = actions.concat(targets)

    const shortestPath = findShortestPath(creature, targets, findEmptyTiles())

    console.log('Shortest path', shortestPath)
    const pathActions = shortestPath.path.map((tile, index) => {
      return {
        type: 'path',
        symbol: index,
        x: tile.x,
        y: tile.y
      }
    })
    actions = actions.concat(pathActions)

    return actions
  }

  function findShortestPath(start, targets, tiles) {
    return targets.map(target => findPath(start, target, tiles))
      .filter(n => n && n.path)
      .sort((a, b) => a.path.length - b.path.length)[0] || {path:[]}
  }

  function findPath(start, target, tiles) {
    const adjacentDirections = [
      {x: 0, y: -1},
      {x: 0, y: 1},
      {x: -1, y: 0},
      {x: 1, y: 0}
    ]
    const tileMap = tiles.reduce((acc, tile) => {
      acc[`${tile.x},${tile.y}`] = tile
      return acc
    }, {})
    const findTile = (x, y) => tileMap[`${x},${y}`] || false

    const path = []
    const open = []
    const closed = []

    // #1
    open.push(start)
    start.open = true
    let searching = true
    // #2
    do {
      // #2 A
      let currentTile = open.sort((a, b) => a.f - b.f).pop()
      if (!currentTile) {
        console.log('No path found for:', start, target, open.length, closed.length)
        searching = false
      }
      else {
        currentTile.open = false
        // console.log('Searching', open.length, closed.length, currentTile)
        // #2 B
        closed.push(currentTile)
        currentTile.closed = true
        if (currentTile.x === target.x && currentTile.y === target.y) {
          searching = false
          // path found
          path.push(currentTile)
          parent = currentTile.parent
          while (parent) {
            path.unshift(parent)
            parent = parent.parent
          }
        }
        else {
          // #2 C
          adjacentDirections.forEach(direction => {
            let newg, parent
            let tile = findTile(currentTile.x + direction.x, currentTile.y + direction.y)
            if (!tile || tile.closed) {
              return
            } else if(!tile.open) {
              open.push(tile)
              tile.open = true
              tile.parent = currentTile
              tile.g = 0
              parent = tile.parent
              while (parent && tile.g < tiles.length) {
                tile.g++
                parent = parent.parent
              }
              tile.h = Math.abs(tile.x - target.x) + Math.abs(tile.y - target.y)
              tile.f = tile.g + tile.h
            }
            else {
              let newg = 0
              let parent = currentTile
              while (parent && newg < tiles.length) {
                newg++
                parent = parent.parent
              }
              if (newg < tile.g) {
                tile.parent = currentTile
                tile.g = newg
                tile.f = tile.g + tile.h
              }
            }
          })
        }
      }
    } while(searching)

    tiles.forEach(tile => {
      delete tile.open
      delete tile.closed
      delete tile.f
      delete tile.h
      delete tile.g
      delete tile.parent
    })

    return {
      start,
      target,
      path
    }
  }

  function displayActions(actions) {
    $actionTiles.forEach($actionTile => $actionTile.detach())
    actions.forEach((action, index) => {
      $actionTile = getActionTile(index)
      $actionTile.css('left', (action.x * 10) + 'px')
      $actionTile.css('top', (action.y * 10) + 'px')
      $actionTile.html(action.symbol)
      $actionTile.attr('class', action.type)
      $chart.append($actionTile)
    })
  }

  renderCreaturePositions($creatures)
})
</script>
<style>
  html, body {
    margin: 20px;
    padding: 0;
    font-family: Arial, sans-serif;
  }
  h1 {
    margin: 10px 0;
  }
  div.chart {
    display: block;
    position: relative;
    zoom: 2.0;
    background: #EEE;
    padding: 0;
    margin: 10px;
    line-height: 9px;
  }
  div.chart > b {
    display: inline-block;
    width: 10px;
    height: 10px;
    font-weight: normal;
    font-size: 10px;
    text-align: center;
    font-family: monospace;
    overflow: hidden;
    color: brown;
  }
  div.chart > b.w {
    background: #333;
    color: #666;
  }
  div.chart > b.f {
    background: #999;
    color: #666;
  }
  div.chart > i {
    display: inline-block;
    position: absolute;
    width: 10px;
    height: 10px;
    overflow: hidden;
    font-style: normal;
    font-size: 10px;
    font-family: monospace;
    text-align: center;
  }
  div.chart > i.e {
    background: blue;
    color: white;
  }
  div.chart > i.g {
    background: green;
    color: black;
  }
  div.chart > a {
    display: inline-block;
    position: absolute;
    width: 10px;
    height: 10px;
    overflow: hidden;
    font-style: normal;
    font-size: 10px;
    font-family: monospace;
    text-align: center;
    background: red;
    color: black;
  }
  div.chart > a.move {
    background: red;
    opacity: 0.7;
  }
  div.chart > a.target {
    background: darkred;
    opacity: 0.7;
  }
  div.chart > a.path {
    background: purple;
    opacity: 0.7;
  }
</style>
</body>
</html>
